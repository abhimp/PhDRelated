\section{Related works and their limitations} 
A number of recent research works, such as~\cite{yadav2016msocket,abdrabou2016experimental,de2016observing,de2016throughput,islam2016start,maity2017tcp,liu2016improving,mpquic-measure} and the references therein, have revisited the TCP design fundamentals considering the needs for optimization at the transport layer, so that the available network capacity can be fully utilized for both the event driven short-lived traffic as well as the real time multimedia streaming traffic.
Consequently, the network community has explored end-to-end protocols to support the above mentioned features at the transport layer. 
{\em Multi-path TCP}~\cite{paasch2014multipath} has been developed for this purpose, where the connection between a sender and a receiver is established via multiple paths through multiple interfaces. A large number of recent works, such as~\cite{oh2016feedback,barik2016lisa} and the references therein, have explored various aspects of MPTCP and measured its performance over dynamic Internet traffic scenarios. However, as explored in~\cite{kheirkhah2016mmptcp}, MPTCP does not perform well for short flows. 
To address the issue of short-lived flows, Dukkipati \textit{et. al.}~\cite{largecwnd} have suggested to use an initial congestion window size of at least $10$, so that the flows can come out of the slow start phase. 
Later Google has developed an application layer protocol called SPDY~\cite{erman2015towards}, that can multiplex multiple web requests over a single TCP connection. However, it suffers from the {\em Head of Line} (HOL) blocking issue; where if one or more packets get lost during transmission, all the flows need to wait until TCP recovers the lost packets. To address the HOL blocking issue, Google has further developed a UDP based experimental protocol called QUIC~\cite{carlucci2015http,cui2017innovating}. QUIC is similar to SPDY, but it uses UDP as the transport layer protocol instead of TCP. QUIC can handle reliability, congestion control and flows control over the Internet. QUIC is developed on top of connection less UDP protocol. Which is a problem for user behind a NAT. So, QUIC developed in such a way so that it can survive port change in the client. However it can not change IP address \cite{quic-deployment}. Also, being an application layer protocol, it does not have any control over the path it selects; and the path selection mechanism is completely dependent on the underlying routing algorithm. Therefore, QUIC is not a truly multi-path protocol and does not support multihoming and mobility. To address these issue, Coninck {\em et. al.} developed MPQUIC in \cite{mpquic-measure} to add support for multi-path and mobility. However, it still have dependency of network stack and it can not decide interface to send the a segment/packet. So, it may not be able to utilize all the interfaces available in a device. 
